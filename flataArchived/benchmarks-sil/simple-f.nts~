// example of a falsifiable formula

l,i,a[N] : int;

check valid
 (
  (forall j:int . ((0 <= j && j <= i-1) -> (a[j] <= a[j+1] - 3))) &&
  (forall j:int . ((i <= j && j <= l-1) -> (a[j] = a[j+1] - 5))) &&
  i>=3 && l>=i+4 && N=l+1
 ) ->
 (forall j:int . ((0 <= j && j <= l-1) -> (a[j] <= a[j+1] - 5)));

// forall scalars N,i,l and arrays a



/*

!((!((((l-N=-1)) && (((i-l<=-4)) && (((-i<=-3)) && ((forall j . (i <= j <= 1-l) -> ((1 * a[j+0] + -1 * a[j+1] + 5 EQ 0))) && (forall j . (0 <= j <= 1-i) -> ((1 * a[j+0] + -1 * a[j+1] + 3 LEQ 0))) || (forall j . (0 <= j <= 1-l) -> ((1 * a[j+0] + -1 * a[j+1] + 5 LEQ 0)))

*/

/*

Syntax: formulas that are boolean combination of atomic predicates
  1) linear inequalities 
  2) array properties: forall k . {lowerbound_term <= i <= upperbound_term} => {array_value constraint}

lowerbound,upperbound: 
   +/- p + c 
   where p is a scalar variable and c is an integer constant

array_value_constraint: of one of the following forms
   +/- a[k+c] +/- b[k+d] <= e 
   +/- a[k+c] +/- p <= e
   +/- a[k+c] <= e
   where c,d,e are integer constants

forall {k}{range}{prop}
range: true or bnd<=k<=bnd
prop: conjunction of array_value_constraint


todo:
  normalize [k+c] to [k+1]
  allow octagonal constraints instead of difference bounds constraints
  allow bnd < i < bnd in the guard
  
  allow quantifiers for integers and eliminate them during preprocessing of the formula
  (for array quantifiers, no nesting is allowed -- only top-level occurrence is supported)

parsing:
  create AST which will be interpreted similarly as in the relational calculator

accepted array terms:
  (1) inside arr-forall: a[i+c] where i is the index variable (tick)
  (2) everywhere else: a[+/-p+c] where p is a scalar


forall i . low <= i <= up => +/- a[i+c] +/- b[i+d] <= e  where c<=d
 becomes
forall i . low+c <= i <= up+c => +/- a[i] +/- b[i+(d-c)] <= e  where c<=d

forall i . low <= i <= up => +/- a[i+c] +/- p <= e  
 becomes
forall i . low+c <= i <= up+c => +/- a[i] +/- p <= e  

forall i . low <= i <= up => +/- a[i+c] +/- i <= e
 becomes
forall i . low+c <= i <= up+c => +/- a[i] +/- (i-c) <= e





normalization:
  for every array-access term of type 2, a[+/-p+c]:
    create a fresh scalar q 
    substitute a[+/-p+c] with q
    conjoin the formula with a new arr-forall formula forall i . {+/-p+c<=i<=+/-p+c} => {a[i]=q}
  replace every forall i . {true / guard} => { F1 /\ ... /\ Fn } with
    forall i . {true / guard} => { F1 }
    ...
    forall i . {true / guard} => { Fn }
  replace every forall i . {true} => +/-a[i+c] +/- b[i+d] <= e where c<=d with
     [[ c-->0, d-->(d-c) ]]
    forall i . {0<=i<=N-(d-c)-1} => +/-a[i] +/- b[i+(d-c)] <= e
  replace every forall i . {true} => +/-a[i+c] +/- p <= e with
     [[ c-->0 ]]
    forall i . {0<=i<=N-1} => +/-a[i] +/- p <= e
  for every forall i . {bnd1<=i<=bnd2} => +/-a[i] +/- b[i+d] <= e (now d>=0 holds), if d>=2, replace it with the conjunction of (aux_1,...aux_{d-1} are fresh array variables)
    forall i . {bnd1<=i<=bnd2} => +/-a[i] - aux_1[i+1] <= 0
    forall i . {bnd1+1<=i<=bnd2+1} => aux_1[i+1] - aux_2[i+1] <= 0
    ...
    forall i . {bnd1+(d-2)<=i<=bnd2+(d-2)} => aux_{d-2}[i+1] - aux_{d-1}[i+1] <= 0 
    forall i . {bnd1+(d-1)<=i<=bnd2+(d-1)} => aux_{d-1}[i+1] +/- b[i+1] <= 0 

normalization:
  

is NTS syntax compatible with SIL?
  

N -- reserved keyword -- integer parameter for common array length
example of a declaration
  p,k,a[N],b[N] : int;
followed by either
  check sat \psi
or
  check valid \psi

restrictions:
  the only allowed array accesses are indexed, i.e. a[p+3] but not 'a'
  array accesses are indexed either by integer variables from declaration or by forall i variables
  
\psi is a formula with free variables from the declaration
\psi may contain quantifiers:
  given a quantifier Q i . \phi in the AST, only two cases are allowed:
    (1) Q is forall, \phi contains array access indexed with i and the subtree from Q contains no further quantifiers
    (2) case 1 applies neither for Q nor for any Q' that is below Q in the AST
  Normalizeation of case 1.
     A) any array access is over declared integer variables, e.g. a[p+3] and can be substituted with a fresh scalar m while conjoining \psi with a[p+3]=m
     B) then, all quantifiers in the subformula rooted at Q can be eliminated, thus obtaining a standard QF-Presburger formula
  restrictions for the case (2):
     forall i . phi_1 => phi_2 
     or forall i . phi_2
     where \phi_1,\phi_2 contains only conjunctions, doesn't contain NEQ, ...
       phi_1 may contain:
          at most one octagonal constraint of the form term<=i
          at most one octagonal constraint of the form i<=term
          nothing else than the above
       array accesses in \phi_2 are of the form [i+c] where c is an integer constant
       \phi_2 is a conjunction of octagonal array terms 

Visitor1:
  go down the line until the first quantifier
    check if the quantifier is arr-forall (see the conditions above -- Visitor2)
      if so, make all the checks (see above -- Visitor 3), build an ArrForall atom and return it
      if not, make all the checks (see above -- Visitor 4), eliminatte all quantifiers, build an Presburger atom and return it
      The part of AST above the quantifiers is copied to create a parallel tructure with  ArrForall and Presburger atoms

Visitor1 needs to 1) count number of quantifiers from the root to the current node, 2) collect quantified varibles (these can be accessed from variable tables), 3) test if an array index contains quantified variable -- if so, then 

Visitor2: starts with a quantifier Q i . \phi
  collects: 
    S -- the set of all quantified variables in the subtree rooted at Q
    A -- the set of all array accesses in the subtree rooted at Q
   (A) arr-forall property IFF Q=forall, S={i}, a[i+c] \in A, and Visitor3 passes the test
   (B) Presburger property IFF for every a[i+c] \in A, i \not\in S (no accesses via quantified variables)
     --> then, call another visitor that replaces array access terms with fresh variables
     --> this gives a Presburger formula without array accesses and all quantifiers can be eliminated
     --> the original formula is conjoined with new arr-forall formulas that code a[j+c]=p

Visitor3: checks that \phi (passed from Visitor2) is either A => B or B where
  A cantains no array accesses, both A and B are conjuctions of octagonal terms
  every octagonal term in A contains one subterm +/- i


VisitorX: check that every array access is indexed, i.e. e.g. no 'a=b'

parsing NTS transition labels: 
  processing formula to DNF
  need to extend it to support 
     (1) arr-forall formula
     (2) array terms in expressions
  (2) can be solved by on-the-fly substitution with fresh variables
  how to detect (1): when a quantifier forall i . psi is visited, check if psi accesses an array with the index i
    if it does, then arr-forall formula is found
       (!) one must check that there is no other quantifier above or below this arr-forall in AST
    write another visitor that will check if a subtree conforms

  upon visiting a top-most quantifier Q, there are two cases:
    Q is forall, its subtree contains no array access 


////

1*a[i+c] <= 4 + i




*/

